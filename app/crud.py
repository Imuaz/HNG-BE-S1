"""
CRUD Operations
---------------
Functions for database operations: Create, Read, Update, Delete

These functions are the "bridge" between our API endpoints and the database.
They handle all SQL queries through SQLAlchemy ORM.
"""

from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from typing import List, Optional, Dict
from app.models import StringModel
from app.analyzer import analyze_string


# ============================================================================
# CREATE Operations
# ============================================================================

def create_string(db: Session, value: str) -> StringModel:
    """
    Creates a new string record in the database with all analyzed properties.
    
    Process:
    1. Analyze the string (compute all properties)
    2. Create a database model instance
    3. Add it to the session (staging area)
    4. Commit the transaction (save to database)
    5. Refresh to get database-generated values (like created_at)
    
    Args:
        db: Database session
        value: The string to store and analyze
    
    Returns:
        The created StringModel instance with all properties
    
    Raises:
        IntegrityError: If string already exists (duplicate)
    
    Example:
        db_string = create_string(db, "hello world")
        print(db_string.id)  # SHA-256 hash
        print(db_string.properties)  # Computed properties
    """
    # Step 1: Analyze the string
    properties = analyze_string(value)
    
    # Step 2: Create database model instance
    # We populate it with analyzed properties
    db_string = StringModel(
    id=properties["sha256_hash"],  # Use hash as primary key (stored as id)
        value=value,
        length=properties["length"],
        is_palindrome=properties["is_palindrome"],
        unique_characters=properties["unique_characters"],
        word_count=properties["word_count"],
    # sha256_hash column removed from model; id already stores the SHA-256 hash
        character_frequency_map=properties["character_frequency_map"]
        # created_at is auto-generated by database
    )
    
    # Step 3: Add to session (not saved yet, just staged)
    db.add(db_string)
    
    # Step 4: Commit transaction (actually save to database)
    # This is where the INSERT SQL query is executed
    db.commit()
    
    # Step 5: Refresh to get database-generated values
    # This fetches the created_at timestamp from the database
    db.refresh(db_string)
    
    return db_string


# ============================================================================
# READ Operations
# ============================================================================

def get_string_by_value(db: Session, value: str) -> Optional[StringModel]:
    """
    Retrieves a string by its exact value.
    
    This does a case-sensitive exact match.
    
    Args:
        db: Database session
        value: The exact string to search for
    
    Returns:
        StringModel if found, None otherwise
    
    Example:
        string = get_string_by_value(db, "hello world")
        if string:
            print(f"Found: {string.value}")
        else:
            print("Not found")
    """
    # SQLAlchemy query:
    # SELECT * FROM strings WHERE value = 'hello world' LIMIT 1
    return db.query(StringModel).filter(StringModel.value == value).first()


def get_string_by_id(db: Session, string_id: str) -> Optional[StringModel]:
    """
    Retrieves a string by its ID (SHA-256 hash).
    
    Args:
        db: Database session
        string_id: The SHA-256 hash (primary key)
    
    Returns:
        StringModel if found, None otherwise
    """
    # SQLAlchemy query:
    # SELECT * FROM strings WHERE id = 'abc123...' LIMIT 1
    return db.query(StringModel).filter(StringModel.id == string_id).first()


def get_all_strings(
    db: Session,
    is_palindrome: Optional[bool] = None,
    min_length: Optional[int] = None,
    max_length: Optional[int] = None,
    word_count: Optional[int] = None,
    contains_character: Optional[str] = None
) -> List[StringModel]:
    """
    Retrieves all strings with optional filtering.
    
    This function builds a dynamic SQL query based on which filters are provided.
    Only applies filters that are not None.
    
    Args:
        db: Database session
        is_palindrome: Filter by palindrome status (optional)
        min_length: Minimum string length, inclusive (optional)
        max_length: Maximum string length, inclusive (optional)
        word_count: Exact word count (optional)
        contains_character: Single character that must be present (optional)
    
    Returns:
        List of StringModel instances matching all provided filters
    
    Example:
        # Get all palindromes with 1 word
        strings = get_all_strings(db, is_palindrome=True, word_count=1)
        
        # Get all strings between 5-10 characters
        strings = get_all_strings(db, min_length=5, max_length=10)
    """
    # Start with base query (all strings)
    query = db.query(StringModel)
    
    # Apply filters conditionally (only if provided)
    
    if is_palindrome is not None:
        # Filter by palindrome status
        # SQL: WHERE is_palindrome = True/False
        query = query.filter(StringModel.is_palindrome == is_palindrome)
    
    if min_length is not None:
        # Filter by minimum length
        # SQL: WHERE length >= min_length
        query = query.filter(StringModel.length >= min_length)
    
    if max_length is not None:
        # Filter by maximum length
        # SQL: WHERE length <= max_length
        query = query.filter(StringModel.length <= max_length)
    
    if word_count is not None:
        # Filter by exact word count
        # SQL: WHERE word_count = word_count
        query = query.filter(StringModel.word_count == word_count)
    
    if contains_character is not None:
        # Filter by character presence
        # SQL: WHERE value LIKE '%a%' (for character 'a')
        # The % are wildcards (match any characters before/after)
        query = query.filter(StringModel.value.like(f"%{contains_character}%"))
    
    # Execute query and return all results
    # SQL: ... ORDER BY created_at DESC (newest first)
    return query.order_by(StringModel.created_at.desc()).all()


# ============================================================================
# DELETE Operations
# ============================================================================

def delete_string(db: Session, value: str) -> bool:
    """
    Deletes a string by its value.
    
    Args:
        db: Database session
        value: The exact string to delete
    
    Returns:
        True if string was deleted, False if not found
    
    Example:
        success = delete_string(db, "hello world")
        if success:
            print("Deleted successfully")
        else:
            print("String not found")
    """
    # Step 1: Find the string
    db_string = get_string_by_value(db, value)
    
    # Step 2: If not found, return False
    if db_string is None:
        return False
    
    # Step 3: Delete the string
    # SQL: DELETE FROM strings WHERE value = 'hello world'
    db.delete(db_string)
    
    # Step 4: Commit the transaction (actually delete from database)
    db.commit()
    
    return True


# ============================================================================
# UTILITY Functions
# ============================================================================

def string_exists(db: Session, value: str) -> bool:
    """
    Checks if a string already exists in the database.
    
    More efficient than get_string_by_value() because it only
    checks for existence without fetching all the data.
    
    Args:
        db: Database session
        value: The string to check
    
    Returns:
        True if string exists, False otherwise
    
    Example:
        if string_exists(db, "hello"):
            print("String already stored")
    """
    # SQLAlchemy query that only checks existence (doesn't fetch data)
    # SQL: SELECT EXISTS(SELECT 1 FROM strings WHERE value = 'hello')
    return db.query(StringModel).filter(StringModel.value == value).first() is not None


def count_strings(db: Session, filters: Dict = None) -> int:
    """
    Counts total strings in database with optional filters.
    
    Args:
        db: Database session
        filters: Optional dictionary of filters (same as get_all_strings)
    
    Returns:
        Number of strings matching the filters
    
    Example:
        total = count_strings(db)
        palindromes = count_strings(db, {"is_palindrome": True})
    """
    query = db.query(StringModel)
    
    if filters:
        # Apply filters if provided (same logic as get_all_strings)
        if filters.get("is_palindrome") is not None:
            query = query.filter(StringModel.is_palindrome == filters["is_palindrome"])
        if filters.get("min_length") is not None:
            query = query.filter(StringModel.length >= filters["min_length"])
        if filters.get("max_length") is not None:
            query = query.filter(StringModel.length <= filters["max_length"])
        if filters.get("word_count") is not None:
            query = query.filter(StringModel.word_count == filters["word_count"])
        if filters.get("contains_character") is not None:
            query = query.filter(StringModel.value.like(f"%{filters['contains_character']}%"))
    
    # Count results instead of fetching them
    # SQL: SELECT COUNT(*) FROM strings WHERE ...
    return query.count()
