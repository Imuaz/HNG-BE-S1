"""
CRUD Operations
---------------
Functions for database operations: Create, Read, Update, Delete

These functions are the "bridge" between our API endpoints and the database.
They handle all SQL queries through SQLAlchemy ORM.
"""

from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from typing import List, Optional, Dict
from datetime import datetime
from app.models import StringModel, TranslationModel, TelexConversationModel
from app.analyzer import analyze_string
import hashlib


# ============================================================================
# CREATE Operations
# ============================================================================

def create_string(db: Session, value: str) -> StringModel:
    """
    Creates a new string record in the database with all analyzed properties.
    
    Process:
    1. Analyze the string (compute all properties)
    2. Create a database model instance
    3. Add it to the session (staging area)
    4. Commit the transaction (save to database)
    5. Refresh to get database-generated values (like created_at)
    
    Args:
        db: Database session
        value: The string to store and analyze
    
    Returns:
        The created StringModel instance with all properties
    
    Raises:
        IntegrityError: If string already exists (duplicate)
    
    Example:
        db_string = create_string(db, "hello world")
        print(db_string.id)  # SHA-256 hash
        print(db_string.properties)  # Computed properties
    """
    # Step 1: Analyze the string
    properties = analyze_string(value)
    
    # Step 2: Create database model instance
    # We populate it with analyzed properties
    db_string = StringModel(
        id=properties["sha256_hash"],  # Use hash as primary key
        value=value,
        length=properties["length"],
        is_palindrome=properties["is_palindrome"],
        unique_characters=properties["unique_characters"],
        word_count=properties["word_count"],
        sha256_hash=properties["sha256_hash"],
        character_frequency_map=properties["character_frequency_map"]
        # created_at is auto-generated by database
    )
    
    # Step 3: Add to session (not saved yet, just staged)
    db.add(db_string)
    
    # Step 4: Commit transaction (actually save to database)
    # This is where the INSERT SQL query is executed
    db.commit()
    
    # Step 5: Refresh to get database-generated values
    # This fetches the created_at timestamp from the database
    db.refresh(db_string)
    
    return db_string


# ============================================================================
# READ Operations
# ============================================================================

def get_string_by_value(db: Session, value: str) -> Optional[StringModel]:
    """
    Retrieves a string by its exact value.
    
    This does a case-sensitive exact match.
    
    Args:
        db: Database session
        value: The exact string to search for
    
    Returns:
        StringModel if found, None otherwise
    
    Example:
        string = get_string_by_value(db, "hello world")
        if string:
            print(f"Found: {string.value}")
        else:
            print("Not found")
    """
    # SQLAlchemy query:
    # SELECT * FROM strings WHERE value = 'hello world' LIMIT 1
    return db.query(StringModel).filter(StringModel.value == value).first()


def get_string_by_id(db: Session, string_id: str) -> Optional[StringModel]:
    """
    Retrieves a string by its ID (SHA-256 hash).
    
    Args:
        db: Database session
        string_id: The SHA-256 hash (primary key)
    
    Returns:
        StringModel if found, None otherwise
    """
    # SQLAlchemy query:
    # SELECT * FROM strings WHERE id = 'abc123...' LIMIT 1
    return db.query(StringModel).filter(StringModel.id == string_id).first()


def get_all_strings(
    db: Session,
    is_palindrome: Optional[bool] = None,
    min_length: Optional[int] = None,
    max_length: Optional[int] = None,
    word_count: Optional[int] = None,
    contains_character: Optional[str] = None
) -> List[StringModel]:
    """
    Retrieves all strings with optional filtering.
    
    This function builds a dynamic SQL query based on which filters are provided.
    Only applies filters that are not None.
    
    Args:
        db: Database session
        is_palindrome: Filter by palindrome status (optional)
        min_length: Minimum string length, inclusive (optional)
        max_length: Maximum string length, inclusive (optional)
        word_count: Exact word count (optional)
        contains_character: Single character that must be present (optional)
    
    Returns:
        List of StringModel instances matching all provided filters
    
    Example:
        # Get all palindromes with 1 word
        strings = get_all_strings(db, is_palindrome=True, word_count=1)
        
        # Get all strings between 5-10 characters
        strings = get_all_strings(db, min_length=5, max_length=10)
    """
    # Start with base query (all strings)
    query = db.query(StringModel)
    
    # Apply filters conditionally (only if provided)
    
    if is_palindrome is not None:
        # Filter by palindrome status
        # SQL: WHERE is_palindrome = True/False
        query = query.filter(StringModel.is_palindrome == is_palindrome)
    
    if min_length is not None:
        # Filter by minimum length
        # SQL: WHERE length >= min_length
        query = query.filter(StringModel.length >= min_length)
    
    if max_length is not None:
        # Filter by maximum length
        # SQL: WHERE length <= max_length
        query = query.filter(StringModel.length <= max_length)
    
    if word_count is not None:
        # Filter by exact word count
        # SQL: WHERE word_count = word_count
        query = query.filter(StringModel.word_count == word_count)
    
    if contains_character is not None:
        # Filter by character presence
        # SQL: WHERE value LIKE '%a%' (for character 'a')
        # The % are wildcards (match any characters before/after)
        query = query.filter(StringModel.value.like(f"%{contains_character}%"))
    
    # Execute query and return all results
    # SQL: ... ORDER BY created_at DESC (newest first)
    return query.order_by(StringModel.created_at.desc()).all()


# ============================================================================
# DELETE Operations
# ============================================================================

def delete_string(db: Session, value: str) -> bool:
    """
    Deletes a string by its value.
    
    Args:
        db: Database session
        value: The exact string to delete
    
    Returns:
        True if string was deleted, False if not found
    
    Example:
        success = delete_string(db, "hello world")
        if success:
            print("Deleted successfully")
        else:
            print("String not found")
    """
    # Step 1: Find the string
    db_string = get_string_by_value(db, value)
    
    # Step 2: If not found, return False
    if db_string is None:
        return False
    
    # Step 3: Delete the string
    # SQL: DELETE FROM strings WHERE value = 'hello world'
    db.delete(db_string)
    
    # Step 4: Commit the transaction (actually delete from database)
    db.commit()
    
    return True


# ============================================================================
# UTILITY Functions
# ============================================================================

def string_exists(db: Session, value: str) -> bool:
    """
    Checks if a string already exists in the database.
    
    More efficient than get_string_by_value() because it only
    checks for existence without fetching all the data.
    
    Args:
        db: Database session
        value: The string to check
    
    Returns:
        True if string exists, False otherwise
    
    Example:
        if string_exists(db, "hello"):
            print("String already stored")
    """
    # SQLAlchemy query that only checks existence (doesn't fetch data)
    # SQL: SELECT EXISTS(SELECT 1 FROM strings WHERE value = 'hello')
    return db.query(StringModel).filter(StringModel.value == value).first() is not None


def count_strings(db: Session, filters: Dict = None) -> int:
    """
    Counts total strings in database with optional filters.
    
    Args:
        db: Database session
        filters: Optional dictionary of filters (same as get_all_strings)
    
    Returns:
        Number of strings matching the filters
    
    Example:
        total = count_strings(db)
        palindromes = count_strings(db, {"is_palindrome": True})
    """
    query = db.query(StringModel)
    
    if filters:
        # Apply filters if provided (same logic as get_all_strings)
        if filters.get("is_palindrome") is not None:
            query = query.filter(StringModel.is_palindrome == filters["is_palindrome"])
        if filters.get("min_length") is not None:
            query = query.filter(StringModel.length >= filters["min_length"])
        if filters.get("max_length") is not None:
            query = query.filter(StringModel.length <= filters["max_length"])
        if filters.get("word_count") is not None:
            query = query.filter(StringModel.word_count == filters["word_count"])
        if filters.get("contains_character") is not None:
            query = query.filter(StringModel.value.like(f"%{filters['contains_character']}%"))
    
    # Count results instead of fetching them
    # SQL: SELECT COUNT(*) FROM strings WHERE ...
    return query.count()


# ============================================================================
# TRANSLATION CRUD OPERATIONS (New for MultiLingo Agent)
# ============================================================================

def create_translation(
    db: Session,
    original_text: str,
    translated_text: str,
    source_language: str,
    target_language: str,
    detected_language_name: str,
    original_properties: Optional[Dict] = None,
    user_id: Optional[str] = None,
    request_source: str = "api"
) -> TranslationModel:
    """
    Creates a new translation record in the database.
    
    Args:
        db: Database session
        original_text: Original text that was translated
        translated_text: The translation result
        source_language: Source language code (e.g., 'en')
        target_language: Target language code (e.g., 'es')
        detected_language_name: Human-readable language name
        original_properties: String analysis properties (optional)
        user_id: User identifier from Telex or other source (optional)
        request_source: Where request came from ('api', 'telex', 'webhook')
    
    Returns:
        Created TranslationModel instance
    """
    # Generate unique ID: hash of original text + target language
    original_hash = hashlib.sha256(original_text.encode('utf-8')).hexdigest()
    translation_id = f"{original_hash[:16]}_{target_language}"
    
    # Create translation record
    db_translation = TranslationModel(
        id=translation_id,
        original_text=original_text,
        original_hash=original_hash,
        detected_language=source_language,
        detected_language_name=detected_language_name,
        target_language=target_language,
        translated_text=translated_text,
        translation_service="deep-translator",
        request_source=request_source,
        user_id=user_id,
        original_properties=original_properties
    )
    
    db.add(db_translation)
    db.commit()
    db.refresh(db_translation)
    
    return db_translation


def get_translation_by_id(db: Session, translation_id: str) -> Optional[TranslationModel]:
    """
    Retrieves a translation by its ID.
    
    Args:
        db: Database session
        translation_id: Translation ID (hash_languagecode)
    
    Returns:
        TranslationModel if found, None otherwise
    """
    return db.query(TranslationModel).filter(TranslationModel.id == translation_id).first()


def get_translation(
    db: Session,
    original_text: str,
    target_language: str
) -> Optional[TranslationModel]:
    """
    Retrieves an existing translation for the same text and target language.
    Useful for caching - avoid re-translating the same text.
    
    Args:
        db: Database session
        original_text: The original text
        target_language: Target language code
    
    Returns:
        TranslationModel if exists, None otherwise
    """
    original_hash = hashlib.sha256(original_text.encode('utf-8')).hexdigest()
    translation_id = f"{original_hash[:16]}_{target_language}"
    
    return get_translation_by_id(db, translation_id)


def get_all_translations(
    db: Session,
    user_id: Optional[str] = None,
    source_language: Optional[str] = None,
    target_language: Optional[str] = None,
    limit: int = 100
) -> List[TranslationModel]:
    """
    Retrieves translation history with optional filtering.
    
    Args:
        db: Database session
        user_id: Filter by user (optional)
        source_language: Filter by source language (optional)
        target_language: Filter by target language (optional)
        limit: Maximum number of results (default 100)
    
    Returns:
        List of TranslationModel instances
    """
    query = db.query(TranslationModel)
    
    if user_id:
        query = query.filter(TranslationModel.user_id == user_id)
    
    if source_language:
        query = query.filter(TranslationModel.detected_language == source_language)
    
    if target_language:
        query = query.filter(TranslationModel.target_language == target_language)
    
    return query.order_by(TranslationModel.created_at.desc()).limit(limit).all()


def delete_translation(db: Session, translation_id: str) -> bool:
    """
    Deletes a translation by its ID.
    
    Args:
        db: Database session
        translation_id: Translation ID to delete
    
    Returns:
        True if deleted, False if not found
    """
    db_translation = get_translation_by_id(db, translation_id)
    
    if db_translation is None:
        return False
    
    db.delete(db_translation)
    db.commit()
    
    return True


# ============================================================================
# TELEX CONVERSATION CRUD OPERATIONS
# ============================================================================

def create_telex_conversation(
    db: Session,
    telex_user_id: str,
    user_message: str,
    agent_response: str,
    detected_intent: Optional[str] = None,
    action_taken: Optional[str] = None,
    telex_conversation_id: Optional[str] = None,
    telex_message_id: Optional[str] = None,
    context_data: Optional[Dict] = None,
    success: bool = True,
    error_message: Optional[str] = None
) -> TelexConversationModel:
    """
    Stores a Telex conversation interaction.
    
    Args:
        db: Database session
        telex_user_id: User ID from Telex
        user_message: What the user said
        agent_response: What our agent responded
        detected_intent: Detected user intent ('translate', 'help', etc.)
        action_taken: Action performed ('translated_to_spanish', etc.)
        telex_conversation_id: Conversation thread ID (optional)
        telex_message_id: Specific message ID (optional)
        context_data: Conversation context (optional)
        success: Whether interaction succeeded
        error_message: Error details if failed (optional)
    
    Returns:
        Created TelexConversationModel instance
    """
    db_conversation = TelexConversationModel(
        telex_user_id=telex_user_id,
        telex_conversation_id=telex_conversation_id,
        telex_message_id=telex_message_id,
        user_message=user_message,
        agent_response=agent_response,
        detected_intent=detected_intent,
        action_taken=action_taken,
        context_data=context_data,
        success=success,
        error_message=error_message
    )
    
    db.add(db_conversation)
    db.commit()
    db.refresh(db_conversation)
    
    return db_conversation


def get_telex_conversation_history(
    db: Session,
    telex_user_id: str,
    limit: int = 50
) -> List[TelexConversationModel]:
    """
    Retrieves conversation history for a Telex user.
    
    Args:
        db: Database session
        telex_user_id: User ID from Telex
        limit: Maximum number of conversations to return
    
    Returns:
        List of TelexConversationModel instances (most recent first)
    """
    return (
        db.query(TelexConversationModel)
        .filter(TelexConversationModel.telex_user_id == telex_user_id)
        .order_by(TelexConversationModel.created_at.desc())
        .limit(limit)
        .all()
    )


# ============================================================================
# Test the CRUD operations (run this file directly)
# ============================================================================

if __name__ == "__main__":
    import sys
    from pathlib import Path
    
    # Add project root to Python path
    # This allows imports like 'from app.database import ...'
    project_root = Path(__file__).parent.parent
    sys.path.insert(0, str(project_root))
    
    from app.database import SessionLocal
    
    print("=" * 60)
    print("Testing CRUD Operations")
    print("=" * 60)
    
    # Create a test session
    db = SessionLocal()
    
    try:
        # Test 1: Create a string
        print("\n✅ Test 1: Create a string")
        test_value = "hello world test"
        
        # First, delete it if it exists (cleanup from previous runs)
        delete_string(db, test_value)
        
        # Create new string
        new_string = create_string(db, test_value)
        print(f"Created: {new_string.value}")
        print(f"ID: {new_string.id}")
        print(f"Properties: length={new_string.length}, palindrome={new_string.is_palindrome}")
        
        # Test 2: Try to create duplicate (should fail)
        print("\n❌ Test 2: Try to create duplicate")
        try:
            duplicate = create_string(db, test_value)
            print("ERROR: Duplicate was allowed!")
        except IntegrityError:
            print("Success! Duplicate was rejected (expected)")
            db.rollback()  # Roll back the failed transaction
        
        # Test 3: Retrieve by value
        print("\n✅ Test 3: Retrieve by value")
        found = get_string_by_value(db, test_value)
        if found:
            print(f"Found: {found.value}")
        else:
            print("Not found")
        
        # Test 4: Get all strings
        print("\n✅ Test 4: Get all strings")
        all_strings = get_all_strings(db)
        print(f"Total strings in database: {len(all_strings)}")
        
        # Test 5: Filter strings
        print("\n✅ Test 5: Filter by word count")
        filtered = get_all_strings(db, word_count=3)
        print(f"Strings with 3 words: {len(filtered)}")
        
        # Test 6: Delete string
        print("\n✅ Test 6: Delete string")
        success = delete_string(db, test_value)
        if success:
            print("Deleted successfully")
        else:
            print("Delete failed")
        
        # Verify deletion
        found = get_string_by_value(db, test_value)
        if found is None:
            print("Verified: String no longer exists")
        
        print("\n" + "=" * 60)
        print("All tests completed!")
        print("=" * 60)
        
    finally:
        db.close()